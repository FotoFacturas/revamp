// newApiWrapper.js - Versi√≥n corregida seg√∫n documentaci√≥n
import * as HTTP from './http';
import { NEW_API_BASE_URL } from './config';

// ‚úÖ Verificar que BASE_URL est√© correcta al inicio del archivo
const BASE_URL = 'https://api-dev.fotofacturas.ai';

console.log('üåê NEW API BASE_URL configurada:', BASE_URL);

class NewApiWrapper {
  constructor() {
    this.baseUrl = BASE_URL;
    this.timeout = 10000; // 10 segundos timeout
  }

  // Helper para headers con JWT
  getAuthHeaders(token, hasBody = true) {
    const headers = {};
    
    // Solo agregar Content-Type si hay body
    if (hasBody) {
      headers['Content-Type'] = 'application/json';
    }
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    return headers;
  }

  // Helper mejorado para requests con manejo de errores y timeout manual compatible con React Native
  async authenticatedRequest(endpoint, options = {}, token) {
    const url = `${this.baseUrl}${endpoint}`;
    const method = options.method || 'GET';
    const hasBody = !!options.body;
    
    // LOGGING DETALLADO
    console.log('\nüîµ ===== NEW API CALL DETAILS =====');
    console.log(`üìç Full URL: ${url}`);
    console.log(`üîß Method: ${method}`);
    console.log(`üè† Base URL: ${this.baseUrl}`);
    console.log(`üìù Endpoint: ${endpoint}`);
    
    if (token) {
      console.log(`üîê Has Token: YES (${token.substring(0, 20)}...)`);
    } else {
      console.log(`üîê Has Token: NO`);
    }
    
    if (options.body) {
      console.log(`üì¶ Body: ${options.body}`);
    }
    
    console.log(`üìã Headers:`, this.getAuthHeaders(token, hasBody));
    console.log('üîµ ================================\n');
    
    // Timeout manual compatible con React Native
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, this.timeout);
    
    const requestOptions = {
      ...options,
      signal: controller.signal,
      headers: {
        ...this.getAuthHeaders(token, hasBody),
        ...options.headers
      }
    };
  
    try {
      const response = await fetch(url, requestOptions);
      clearTimeout(timeoutId); // Limpiar timeout si la request es exitosa
      
      // LOGGING DE RESPONSE DETALLADO
      console.log('\n‚úÖ ===== RESPONSE DETAILS =====');
      console.log(`üì° Status: ${response.status} ${response.statusText}`);
      console.log(`üåê URL Called: ${url}`);
      console.log(`‚è±Ô∏è Method: ${method}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.log(`‚ùå Error Response: ${errorText}`);
        console.log('‚úÖ =============================\n');
        
        const error = new Error(`HTTP_${response.status}: ${errorText}`);
        error.status = response.status;
        error.statusText = response.statusText;
        throw error;
      }

      const result = await response.json();
      console.log(`‚úÖ Success Response:`, { 
        isSuccess: result.isSuccess,
        hasData: !!result.data,
        dataKeys: result.data ? Object.keys(result.data) : []
      });
      console.log('‚úÖ =============================\n');
      
      return result;
      
    } catch (error) {
      clearTimeout(timeoutId); // Limpiar timeout en caso de error
      
      if (error.name === 'AbortError') {
        console.error(`‚è∞ Timeout en ${endpoint} despu√©s de ${this.timeout}ms`);
        throw new Error(`REQUEST_TIMEOUT: ${endpoint}`);
      }
      
      if (error.name === 'TypeError') {
        console.error(`üåê Error de red en ${endpoint}:`, error.message);
        throw new Error(`NETWORK_ERROR: ${error.message}`);
      }
      
      console.error(`‚ùå Error en ${endpoint}:`, error.message);
      throw error;
    }
  }

  // === M√âTODOS DE AUTENTICACI√ìN ===

  async requestLoginOtpEmail(email) {
    console.log('üìß requestLoginOtpEmail called with email:', email);
    if (!email || !email.includes('@')) {
      throw new Error('INVALID_EMAIL: Email requerido y v√°lido');
    }
    // ‚úÖ URL CORRECTA seg√∫n swagger
    const url = `${this.baseUrl}/Api/MobileV1Security/RequestLoginOtpEmail`;
    return fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({ email })
    }).then(async response => {
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.message || `HTTP error! status: ${response.status}`);
      }
      if (!data.isSuccess) {
        throw new Error(data.message || 'RequestLoginOtpEmail fall√≥');
      }
      return data;
    });
  }

  async loginOtpEmail(email, otp) {
    console.log('üîì loginOtpEmail called with email:', email, 'otp:', otp);
    if (!email || !otp) {
      throw new Error('MISSING_PARAMS: Email y OTP requeridos');
    }
    if (otp.length < 4) {
      throw new Error('INVALID_OTP: OTP debe tener al menos 4 d√≠gitos');
    }
    // ‚úÖ URL CORRECTA seg√∫n swagger
    const url = `${this.baseUrl}/Api/MobileV1Security/LoginOtpEmail`;
    return fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({ email, otp })
    }).then(async response => {
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.message || `HTTP error! status: ${response.status}`);
      }
      if (!data.isSuccess) {
        throw new Error(data.message || 'LoginOtpEmail fall√≥');
      }
      return data;
    });
  }

  async requestLoginOtpPhone(phone) {
    console.log('üì± requestLoginOtpPhone called with phone:', phone);
    if (!phone) {
      throw new Error('MISSING_PHONE: N√∫mero de tel√©fono requerido');
    }
    return this.authenticatedRequest('/MobileV1Security/RequestLoginOtpPhone', {
      method: 'POST',
      body: JSON.stringify({ phone })
    });
  }

  async loginOtpPhone(phone, otp) {
    console.log('üîì loginOtpPhone called with phone:', phone, 'otp:', otp);
    if (!phone || !otp) {
      throw new Error('MISSING_PARAMS: Tel√©fono y OTP requeridos');
    }
    return this.authenticatedRequest('/MobileV1Security/LoginOtpPhone', {
      method: 'POST',
      body: JSON.stringify({ phone, otp })
    });
  }

  // === M√âTODOS DE SESI√ìN ===
  // Seg√∫n seguridad.md: /Api/MobileV1/KeepSession

  async keepSession(token) {
    console.log('üîÑ keepSession called - POST sin body, solo Authorization header');
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    // ‚úÖ URL CORRECTA seg√∫n swagger
    const url = `${this.baseUrl}/Api/MobileV1Security/KeepSession`;
    return fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    }).then(async response => {
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.message || `HTTP error! status: ${response.status}`);
      }
      if (!data.isSuccess) {
        throw new Error(data.message || 'KeepSession fall√≥');
      }
      return data;
    });
  }

  // === M√âTODOS DE VERIFICACI√ìN OTP ===
  // Seg√∫n seguridad.md: /Api/MobileV1/RequestVerifyOtpEmail

  async requestVerifyOtpEmail(token) {
    console.log('üìß requestVerifyOtpEmail called');
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    // ‚úÖ URL CORRECTA (seg√∫n swagger):
    return this.authenticatedRequest('/Api/MobileV1Security/RequestVerifyOtpEmail', {
      method: 'POST'
    }, token);
  }

  async validateOtpEmail(token, otp) {
    console.log('‚úÖ validateOtpEmail called with otp:', otp);
    
    if (!token || !otp) {
      throw new Error('MISSING_PARAMS: Token y OTP requeridos');
    }
    
    return this.authenticatedRequest('/Api/MobileV1Security/ValidateOtpEmail', {
      method: 'POST',
      body: JSON.stringify({ otp })
    }, token);
  }

  async requestVerifyOtpPhone(token) {
    console.log('üì± requestVerifyOtpPhone called');
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    return this.authenticatedRequest('/Api/MobileV1Security/RequestVerifyOtpPhone', {
      method: 'POST'
    }, token);
  }

  async validateOtpPhone(token, otp) {
    console.log('‚úÖ validateOtpPhone called with otp:', otp);
    
    if (!token || !otp) {
      throw new Error('MISSING_PARAMS: Token y OTP requeridos');
    }
    
    return this.authenticatedRequest('/Api/MobileV1Security/ValidateOtpPhone', {
      method: 'POST',
      body: JSON.stringify({ otp })
    }, token);
  }

  // === M√âTODOS DE USUARIO ===
  // Seg√∫n usuario.md: /Api/MobileV1/GetUserData, /Api/MobileV1/AddUser

  async getUserData(token) {
    console.log('üë§ getUserData called with token:', token ? 'YES' : 'NO');
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    return this.authenticatedRequest('/Api/MobileV1User/GetUserData', {
      method: 'GET'
    }, token);
  }

  async updateUser(token, updateData) {
    console.log('üìù updateUser called with data:', Object.keys(updateData));
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    return this.authenticatedRequest('/Api/MobileV1User/UpdateUser', {
      method: 'PUT',
      body: JSON.stringify(updateData)
    }, token);
  }

  async addUser(userData) {
    console.log('‚ûï addUser called with:', userData);
    
    const url = `${this.baseUrl}/Api/MobileV1User/AddUser`;
    
    // Mapear fullName a name y pSurname (asumiendo formato "Nombre Apellido")
    let name = '';
    let pSurname = '';
    let mSurname = '';
    if (userData.fullName) {
      const parts = userData.fullName.trim().split(' ');
      name = parts[0] || '';
      pSurname = parts[1] || '';
      mSurname = parts.slice(2).join(' ') || '';
    }
    // Si no hay mSurname, dejarlo vac√≠o
    
    const payload = {
      associationId: 1,
      email: userData.email,
      name,
      pSurname,
      mSurname,
      phone: userData.phone,
      phoneCode: userData.phoneCode
    };
    
    console.log('\nüîµ ===== NEW API CALL DETAILS =====');
    console.log('üìç Full URL:', url);
    console.log('üîß Method: POST');
    console.log('üì¶ Body:', JSON.stringify(payload));
    console.log('üìã Headers:', {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    });
    console.log('üîµ ================================\n');
    
    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: JSON.stringify(payload)
      });
      
      console.log('\n‚úÖ ===== RESPONSE DETAILS =====');
      console.log('üì° Status:', response.status);
      console.log('üìä Status Text:', response.statusText);
      console.log('üåê URL Called:', url);
      console.log('‚è±Ô∏è Method: POST');
      console.log('üìã Response Headers:', JSON.stringify([...response.headers.entries()]));
      
      // ‚úÖ Verificar si la respuesta tiene contenido
      const responseText = await response.text();
      console.log('üìÑ Raw Response Text:', responseText);
      console.log('üìè Response Length:', responseText.length);
      console.log('‚úÖ =============================\n');
      
      if (!response.ok) {
        console.error('‚ùå HTTP Error:', response.status, response.statusText);
        throw new Error(`HTTP_${response.status}: ${response.statusText}`);
      }
      
      // ‚úÖ Intentar parsear JSON solo si hay contenido
      if (!responseText || responseText.length === 0) {
        console.error('‚ùå Respuesta vac√≠a del servidor');
        throw new Error('Respuesta vac√≠a del servidor');
      }
      
      let data;
      try {
        data = JSON.parse(responseText);
        console.log('üì• [NEW API] AddUser parsed response:', data);
      } catch (parseError) {
        console.error('‚ùå Error parseando JSON:', parseError);
        console.error('‚ùå Raw response que caus√≥ el error:', responseText);
        throw new Error(`JSON Parse Error: ${parseError.message}`);
      }
      
      if (!data.isSuccess) {
        throw new Error(data.message || 'AddUser fall√≥');
      }
      
      return data; // Retorna FFResponse
      
    } catch (error) {
      console.error('‚ùå [NEW API] AddUser error:', error);
      throw error;
    }
  }

  // === M√âTODOS DE INFORMACI√ìN FISCAL ===
  // Seg√∫n usuario.md: /Api/MobileV1/AddUserTaxInfo, /Api/MobileV1/AddUserTaxInfoAutomated

  async addUserTaxInfo(token, taxInfoData) {
    console.log('üèõÔ∏è addUserTaxInfo called');
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    return this.authenticatedRequest('/AddUserTaxInfo', {
      method: 'POST',
      body: JSON.stringify(taxInfoData)
    }, token);
  }

  async addUserTaxInfoAutomated(token, pdfFile) {
    console.log('ü§ñ addUserTaxInfoAutomated called');
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    const formData = new FormData();
    formData.append('file', {
      uri: pdfFile.uri,
      type: 'application/pdf',
      name: pdfFile.name || 'csf.pdf'
    });

    return this.authenticatedRequest('/AddUserTaxInfoAutomated', {
      method: 'POST',
      body: formData,
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    }, token);
  }

  // === M√âTODOS DE TICKETS ===
  // Seg√∫n ticket.md: /Api/MobileV1/GetTickets, /Api/MobileV1/AddTicket

  async getTickets(token) {
    console.log('üé´ getTickets called');
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    return this.authenticatedRequest('/GetTickets', {
      method: 'GET'
    }, token);
  }

  async getTicket(token, ticketId) {
    console.log('üé´ getTicket called with ID:', ticketId);
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    // TODO: Verificar si ticketId va en query params o en path seg√∫n swagger
    return this.authenticatedRequest(`/GetTicket?ticketId=${ticketId}`, {
      method: 'GET'
    }, token);
  }

  async addTicket(token, ticketData) {
    console.log('‚ûï addTicket called');
    
    if (!token) {
      throw new Error('MISSING_TOKEN: Token de sesi√≥n requerido');
    }
    
    const formData = new FormData();
    
    // Agregar imagen
    if (ticketData.image) {
      formData.append('file', {
        uri: ticketData.image.uri,
        type: 'image/jpeg',
        name: 'ticket.jpg'
      });
    }
    
    // Agregar otros datos del ticket
    Object.keys(ticketData).forEach(key => {
      if (key !== 'image') {
        formData.append(key, ticketData[key]);
      }
    });

    return this.authenticatedRequest('/AddTicket', {
      method: 'POST',
      body: formData,
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    }, token);
  }

  // === M√âTODOS DE CONFIGURACI√ìN ===

  setTimeout(ms) {
    this.timeout = ms;
    console.log(`‚öôÔ∏è Timeout configurado a ${ms}ms`);
  }

  // M√©todo para test b√°sico de conectividad
  async ping() {
    try {
      const startTime = Date.now();
      await this.authenticatedRequest('/ping', { method: 'GET' });
      const responseTime = Date.now() - startTime;
      console.log(`üèì Ping exitoso: ${responseTime}ms`);
      return { success: true, responseTime };
    } catch (error) {
      console.log(`üèì Ping fall√≥: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  // M√©todo para verificar conectividad b√°sica
  async testConnection() {
    try {
      console.log(`üåê Testing connection to: ${this.baseUrl}`);
      const response = await fetch(this.baseUrl.replace('/Api/MobileV1', '/health') || this.baseUrl);
      console.log(`üåê Connection test result: ${response.status}`);
      return response.status < 500;
    } catch (error) {
      console.log(`üåê Connection test failed: ${error.message}`);
      return false;
    }
  }
}

export default new NewApiWrapper();